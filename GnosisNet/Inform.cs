using System.Reflection;
using System.Linq.Expressions;
using System;
using System.Collections.Generic;
using Microsoft.CSharp.Expressions;

namespace Gnosis
{
    public partial class Inform
    {
        string OutputField(FieldInfo field, object gameClass)
        {
            string GetTypeString(System.Type t)
            {
                if (t == typeof(bool))
                    return "truth state";
                if (t == typeof(string))
                    return "text";
                if (t == typeof(int))
                    return "number";
                if (t == typeof(Thing))
                    return "thing";

                throw new System.Exception("invalid global field");
            }

            var typeStr = GetTypeString(field.FieldType);
            var objvalue = field.GetValue(gameClass);

            string s = field.Name + " is a " + typeStr + " that varies. " + field.Name + " is initially " + objvalue.ToString() + ".\n";

            return s;
        }

        string OutputGlobalFields(object gameClass)
        {
            var s = "";
            var type = gameClass.GetType();
            var fields = type.GetFields();
            foreach(var field in fields)
            {
                s += OutputField(field, gameClass);
            }
            
            return s;
        }


        string OutputRuleBody(Rule rule)
        {
            string s = "";

            var bodyVisitor = new BodyVisitor();
            rule.body = rule.body.Reduce();
            rule.body = rule.body.ReduceExtensions();

            bodyVisitor.Visit(rule.body);

            s += bodyVisitor.s;

            return s;
        }


        string OutputRule(Rule rule)
        {
            var s = rule.type.ToString() + " " + rule.applyingTo.name;
            if(rule.condition != null)
            {
                s += " when ";

                var expr = rule.condition;
                if (expr is Expression<Predicate<Thing>> thingExpr)
                {
                    var visitor = new ExpressionMachine();
                    visitor.Visit(expr);
                    s += visitor.s + ":\n";
                }
            }

            s += OutputRuleBody(rule);

            return s;
        }


        string OutputKinds()
        {
            string s = "";

            var gameAssembly = Assembly.GetEntryAssembly();
            var types = gameAssembly.GetTypes();
            foreach(var type in types)
            {
                if(type.GetCustomAttribute<KindAttribute>() != null)
                {
                    var baseClass = type.BaseType;
                    s += type.Name + " is a kind of " + baseClass.Name + ".\n";
                    foreach(var inter in type.GetInterfaces())
                    {
                        var members = inter.GetMembers();
                        var either = members.Length == 4;
                        if(!either)
                        {
                            s += "a " + type.Name + " can be " + members[1].Name + ".\n";
                        }
                        else
                        {
                            s += "a " + type.Name + " can be " + members[2].Name + " or " + members[3].Name + ".\n";
                        }

                    }
                }
            }

            return s;
        }

        string OutputRoom(Room room)
        {
            var s = room.name + " is a room. The description is \"" + room.description + "\"\n";
            foreach(var connection in room.connections)
            {
                s += connection.Item1.ToString() + " of " + room.name + " is " + connection.Item2.name + ".\n";
            }
            return s;
        }

        string OutputThing(Thing thing, Room location, Thing container)
        {
            var s = "";
            if(location != null)
                s = thing.name + " is a " + thing.GetType().Name + " in " + location.name + ". ";

            if(container != null)
                s = thing.name + " is a " + thing.GetType().Name + " on " + container.name + ". ";

            s += "The description is \"" + thing.description + "\"\n";


            foreach(var alias in thing.aliases)
            {
                s += "Understand \"" + alias + "\" as " + thing.name + ".\n";
            }


            if(thing is Supporter supporter)
            {
                foreach(var subthing in supporter.things)
                {
                    s += OutputThing(subthing, null, supporter);
                }
            }

            return s;
        }




        public string OutputInform(object game)
        {
            var output = "Generated by Kelly MacNeill begins here.\n";

            output += OutputKinds();

            output += OutputRule(Rule.rules[0]);

            output += OutputGlobalFields(game);

            foreach (var room in Globals.rooms)
            {
                output += OutputRoom(room);
    
                foreach (var thing in room.things)
                {
                    output += OutputThing(thing, room, null);
                }
            }


            output += "Generated ends here.\n";

            return output;
        }
    }
}
